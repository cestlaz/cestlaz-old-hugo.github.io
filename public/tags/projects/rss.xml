<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>projects on C&#39;est la Z</title>
    <link>https://cestlaz.github.io/tags/projects/</link>
    <description>C&#39;est la Z (projects)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 29 Feb 2024 12:48:54 -0400</lastBuildDate>
    
    <atom:link href="https://cestlaz.github.io/tags/projects/rss.xml" rel="self" type="application/rss" />
    
    
    <item>
      <title>Real world projects or made up ones?</title>
      <link>https://cestlaz.github.io/post/real-world-projects/</link>
      <pubDate>Thu, 29 Feb 2024 12:48:54 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/real-world-projects/</guid>
      <description>&lt;p&gt;
There was a discussion to day on a the Facebook CS Educators group
about project based learning. This was initiated based on the College
Board&amp;#39;s desire to more more project work in some classes including
APCS-A.&lt;/p&gt;
&lt;p&gt;
Most, actually I think all of the  educators on the forum agreed that
students creating projects are a good idea but the bone of contention
was over real world projects vs what I&amp;#39;ll call practice projects.&lt;/p&gt;
&lt;p&gt;
The thought is that a real world project would be a program that they
might do if they were at a business - a complete web app for instance
or a game, soup to nuts. A made up project might be implementing a
sort or a data structure.&lt;/p&gt;
&lt;p&gt;
In the discussion some felt that all projects should be real world
arguing that students will be more engaged. Others felt that while real
world projects should be a goal, made up projects were more
appropriate at times - like how you&amp;#39;ll practice etudes on a musical
instrument when developing your chops rather than only ever working on
a piece.&lt;/p&gt;
&lt;p&gt;
I don&amp;#39;t agree with the stance that real world projects are more
engaging. Let&amp;#39;s take games - something always paraded out as real
world and engaging. Sure, to kids who like computer gaming. Not so
much for everyone else. Personally, I&amp;#39;m not huge on gaming and neither
were many of my students. That said, enough were so that it made sense
to explore game projects in some classes and to certainly allow them
on appropriate open ended projects.&lt;/p&gt;
&lt;p&gt;
Let&amp;#39;s contrast that to made up projects. I&amp;#39;ve done assorted graphics
projects and many had zero real world ramifications but many (not
all) students found them super engaging. I&amp;#39;ve also frequently done a
computer Caesar Cipher decoder. Many students found it very
engaging. It wasn&amp;#39;t real world but it gave a level appropriate
foreshadowing of a lot to come - proto-AI, proto-math, proto-stats.&lt;/p&gt;
&lt;p&gt;
Not real world but very engaging and I&amp;#39;d argue, more valuable than
forcing a real world project that was less appropriate for what we
were learning.&lt;/p&gt;
&lt;p&gt;
Besides, let&amp;#39;s look at some real, real world projects. Here are some
projects that software engineers I know have worked on:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;make a round button that launches an already built feature of our
platform.&lt;/li&gt;
&lt;li&gt;I changed my mind, make it more of a rectangle with rounded
courners.&lt;/li&gt;
&lt;li&gt;Move that UI component down 3 pixels and over 5.&lt;/li&gt;
&lt;li&gt;Change all the calls in our code base to function f so that it no
longer passes null as the final parameter so that it matches the
new API spec.&lt;/li&gt;
&lt;li&gt;Write a function to check a string to make sure it conforms to our
input specification.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The list goes on. The truth is more real world programmers work on
small bits of a larger system. They&amp;#39;re working in teams (something I
think our students have to learn about, but not exclusively) on large
systems. Very rarely does someone in the real world go from concept to
completion all by themselves, although I think CS programs would
better serve their students if they did teach this manner of &amp;#34;software
architecting.&amp;#34;&lt;/p&gt;
&lt;p&gt;
So, really, real world can be fine but it&amp;#39;s not the be all and end
all.&lt;/p&gt;
&lt;p&gt;
Some might mean &amp;#34;uses real world data&amp;#34; for real world and this can
certainly work. I frequently assign data based projects - find a data
source, collect it, clean it, and do something with it. If the
students can find data they like that can be super motivating but
again, it&amp;#39;s not a be all and end all. I&amp;#39;ve had students go nuts over
writing a Mandelbrot set explorer - no data there and not real world
but super exciting for some.&lt;/p&gt;
&lt;p&gt;
I haven&amp;#39;t even really addressed group work or solo but I think this
post is long enough as it is.&lt;/p&gt;
&lt;p&gt;
The truth is, authentic assignments come in all shapes and sizes and
can be inspired by all sorts of things. Real world, whatever that
means can be great but are not always appropriate. In K12, most
schools top out with CS0 (APCS-P or similar) or CS1 (APCS-A or
similar) not much in the real world is CS0 level - real world data,
real world ideas, yes but not real, real world. Made up assignments
can be as good or better and freed from the constraints of real world
can be much more appropriate for a students development and just as if
not more motivating.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Rite Of Passage Projects</title>
      <link>https://cestlaz.github.io/posts/rite-of-passage-projects/</link>
      <pubDate>Fri, 17 Aug 2018 00:00:00 +0000</pubDate>
      
      <guid>https://cestlaz.github.io/posts/rite-of-passage-projects/</guid>
      <description>&lt;p&gt;
JCS&amp;#39;s &lt;a href=&#34;https://irreal.org/blog/?p=7414#comment-4045190612&#34;&gt;post&lt;/a&gt; on Irreal today brought me back. It was about &lt;a href=&#34;https://en.wikipedia.org/wiki/Brief_(text_editor)&#34;&gt;Brief&lt;/a&gt; which
was the editing hotness back in the day. I played with it a little
really mostly used Emacs clones for real work when I was stuck on
MS-DOS systems. Usually either &lt;a href=&#34;https://en.wikipedia.org/wiki/JOVE&#34;&gt;JOVE&lt;/a&gt; or &lt;a href=&#34;https://en.wikipedia.org/wiki/Epsilon_(text_editor)&#34;&gt;Epsilon&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;
In the comments Jon reminded me about the &lt;a href=&#34;https://en.wikipedia.org/wiki/MKS_Toolkit&#34;&gt;MKS Toolkit&lt;/a&gt;
which brought most everyday Unix tools to DOS along with a shell and
a version of Vi. I didn&amp;#39;t use Vi much and I only used their shell
until I wrote my own.&lt;/p&gt;
&lt;p&gt;
This got me thinking about &amp;#34;rite of passage&amp;#34; projects. I was in
college in the mid to late 80s. It was the heyday of the
IBM-PC. Schools still used older time sharing systems like DEC-20s and
Vaxen but the PC was all the rage. The cool thing about them was that
you had full control and access to the machine and it was simple
enough to get your head around pretty much everything about it. The
downside was that MS-DOS was very limited and of course there was
little to no networking going on.&lt;/p&gt;
&lt;p&gt;
On the one hand, you could dive into the low level machine language
stuff very easily. Get Norton&amp;#39;s book:&lt;/p&gt;
&lt;img src=&#34;https://covers.openlibrary.org/b/id/7446489-L.jpg&#34; alt=&#34;https://covers.openlibrary.org/b/id/7446489-L.jpg&#34; title=&#34;https://covers.openlibrary.org/b/id/7446489-L.jpg&#34; align=&#34;center&#34; height=&#34;250&#34;/&gt;
&lt;p&gt;
and you&amp;#39;re on your way.&lt;/p&gt;
&lt;p&gt;
On the other hand many student&amp;#39;s graduated with no concept of time
sharing and the ramifications of sharing a system or resources were
foreign to many kids.&lt;/p&gt;
&lt;p&gt;
Even though we always look back to the &amp;#34;good old days,&amp;#34; in many ways
things weren&amp;#39;t much different. I got a very strong background in
academic CS from NYU (Courant Institute) but just like today, there
was no real preparation for the real world.If you wanted to really develop your
coding chops you had to work on side projects.&lt;/p&gt;
&lt;p&gt;
I seem to recall, a typical &amp;#34;rite of passage&amp;#34; side project was writing
your own shell. It didn&amp;#39;t have to be anything as powerful as BASH or
ZSH but it would typically be much more powerful than DOS and much
more Unixy.&lt;/p&gt;
&lt;p&gt;
I recall writing my first shell down in UC-49 of Tisch Hall when the
computer labs weren&amp;#39;t busy. I wrote it in C which was what the cool
kids used back then. Specifically I used the &lt;a href=&#34;https://en.wikipedia.org/wiki/Mark_Williams_Company&#34;&gt;Let&amp;#39;s C&lt;/a&gt; compiler from the
Mark Williams company. This was before Turbo C 2.0 so Let&amp;#39;s C was
pretty much the only game in town for a cheap Unix style C compiler
for DOS. There was also Run/C but that was a C interpreter, not a
compiler. I also used that to learn C. Funny story - I certainly
didn&amp;#39;t know this at the time but Run/C was written by Peter
Brooks. Peter and I would later meet when he became my colleague at
Stuyvesant teaching CS and I now have the privilege of being able to
call him friend. I joke that I owe him ~ $100 for the interpreter from
back in the day.&lt;/p&gt;
&lt;p&gt;
Since this was on DOS, I couldn&amp;#39;t do real Unix style pipes like
&lt;code&gt;cat file | sort | uniq -c | sort -n&lt;/code&gt; but I did simulate it with redirection and temporary
files. It also supported aliases, simple scripts and I think a few
other things.&lt;/p&gt;
&lt;p&gt;
I was pretty happy with it and used it for a couple of years. It was
also one of the first substantial programs I wrote. I learned a lot
from doing it.&lt;/p&gt;
&lt;p&gt;
Another &amp;#34;rite of passage&amp;#34; program that was common back then was a
text based window library. Somethig like ncurses that would allow you
to make text based windows and menus on the text only screen. I also
wrote one of these and actually got to use it for a project when I
started working at Goldman.&lt;/p&gt;
&lt;p&gt;
I guess the third &amp;#34;rite of passage&amp;#34; project I remember was writing a C
compiler but that was different because it was for a class. It was a
significant project but the class didn&amp;#39;t really help with writing a
large program in general - it was all about the compiler and all the
theory behind it. Great course but not one in software engineering.&lt;/p&gt;
&lt;p&gt;
Nowadays the projects have changed. Text based windowing is long gone
and while I still think writing a shell is a useful and rewarding
exercise it&amp;#39;s not scratching an itch the way it did back when we were
stuck on DOS. I guess writing a full stack web app is probably a
pretty typical one for students these days.&lt;/p&gt;
&lt;p&gt;
Any others?&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>