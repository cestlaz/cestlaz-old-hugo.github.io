<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>programming languages on C&#39;est la Z</title>
    <link>https://cestlaz.github.io/tags/programming-languages/</link>
    <description>C&#39;est la Z (programming languages)</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 11 Oct 2024 12:05:37 -0400</lastBuildDate>
    
    <atom:link href="https://cestlaz.github.io/tags/programming-languages/rss.xml" rel="self" type="application/rss" />
    
    
    <item>
      <title>Authentic Languages</title>
      <link>https://cestlaz.github.io/post/authentic-languages/</link>
      <pubDate>Fri, 11 Oct 2024 12:05:37 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/authentic-languages/</guid>
      <description>&lt;p&gt;
Language wars in tech are common. Java vs C++, Functional vs OOP. If
you&amp;#39;re doing functional is your language functional enough?&lt;/p&gt;
&lt;p&gt;
So to in CS Education. What&amp;#39;s the best language for CS0? For CS1? Drag
and Drop or text based? Functional? Object Oriented? Compiled?
Interpreted?&lt;/p&gt;
&lt;p&gt;
The battles rage on.&lt;/p&gt;
&lt;p&gt;
One particular &amp;#34;war&amp;#34; that I&amp;#39;ve been a part of deals with the idea of a
language&amp;#39;s being authentic or real. I&amp;#39;ve been a part of this on two
fronts.&lt;/p&gt;
&lt;p&gt;
I guess most visibly this has been with Scratch and other drag and
drop languages. People sometimes perceive me as being anti drag and
drop. This is not the case. I love drag and drop languages for the
earlier grades. My issue is that I haven&amp;#39;t seen an advantage to using
them in the later grades. I haven&amp;#39;t seen evidence that knowledge
transfers when an older student - say high school 10th grader or
beyond starts with a Drag and Drop language and then switches to text
based. I&amp;#39;ve also called out what I see as disadvantages of drag and
drop languages in the later grades - what I call jigsaw puzzle
debugging or programming where students write and debug programs by
seeing which block fits geometrically as opposed to thinking through
the problems and also the small screens students usually use are a
limiting factor when writing complex, large programs.&lt;/p&gt;
&lt;p&gt;
I never thought that drag and drop languages like Scratch were
inauthentic or less real than, say Java.&lt;/p&gt;
&lt;p&gt;
That said, there are those who do. I think it comes mostly from
parents and students who feel &amp;#34;they don&amp;#39;t use it in the real world.&amp;#34;
Probably also from hardcore programmers who, even though scratch is
Turing Complete, feel that it&amp;#39;s less of a language.&lt;/p&gt;
&lt;p&gt;
I&amp;#39;ve never taught scratch in a formal class so I never had to deal
with any push back. I&amp;#39;ve only used it in one offs like teacher
professional developments or working with students for some side event
or project.&lt;/p&gt;
&lt;p&gt;
On the other hand, I&amp;#39;ve heard the same complaints when teaching
languages like Racket (nee Scheme) and NetLogo. They&amp;#39;re not real
languages. Nobody uses them in the real world. I&amp;#39;d particularly hear
it about NetLogo which is a wonderful language, particularly for
visual modelling and simulation.&lt;/p&gt;
&lt;p&gt;
Never mind that languages don&amp;#39;t have to be used in the real world in
order to be real and to be of tremendous value in the
classroom. Racket is wonderful for teaching functional
programming. It&amp;#39;s also a super small language with a simple consistent
syntax which makes it, when taught right, beginner friendly. NetLogo
is interactive, visual and allows for students with little experience
to explore complex concepts. In my classes at Stuy, we wrote a maze
solver that used implemented a cellular automaton and also explored
predator prey models all during one unit in our CS0 class.&lt;/p&gt;
&lt;p&gt;
Even if a lesser known language, something seen (incorrectly) as
inauthentic can truly have an impact.&lt;/p&gt;
&lt;p&gt;
I saw that just the other day.&lt;/p&gt;
&lt;p&gt;
I found out that one of my former students was on the team that just
won the Nobel Prize in Chemistry. Just seeing the news made my week.&lt;/p&gt;
&lt;p&gt;
I of course sent a congratulations. As part of his response, he wrote:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;You know, I can trace a lot of my interest in
computational science back to playing with NetLogo turtles simulating
things, exploring cellular automata rules, and graphics.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;
All the stuff we did in Stuyvesant&amp;#39;s required intro CS class.&lt;/p&gt;
&lt;p&gt;
I don&amp;#39;t know if the intro course as a whole made a difference in his
life and career - he might have gone down the CS path regardless. It
is clear though that using NetLogo in the intro class did ignite a
spark. Had we used say Java or C++ from the get go. maybe this never
happens.&lt;/p&gt;
&lt;p&gt;
The whole line about inauthentic languages is really hogwash
anyway. Sure, some teachers use the wrong language the wrong way at
the wrong time but most languages can be the &amp;#34;right one&amp;#34; under the
right circumstances.&lt;/p&gt;
&lt;p&gt;
In this case, it was NetLogo at Stuyvesant in tenth grade in our
required CS class.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Which low level language to teach?</title>
      <link>https://cestlaz.github.io/post/which-low-level/</link>
      <pubDate>Tue, 06 Feb 2024 07:09:37 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/which-low-level/</guid>
      <description>
&lt;p&gt;
A teacher in one of the CSEd forums I&amp;#39;m part of asked for thoughts on
what low level language to teach. She also asked about scripting but
I&amp;#39;m not going address that here. The question came, aparently due to
state guidelines which were somewhat vague. I couldn&amp;#39;t find the
specific guidelines but I did find old guidelines that indicated that
the course in question was intended to be post APCS-A.&lt;/p&gt;
&lt;p&gt;
Back at Stuy, I designed a systems programming course that was post
APCS-AB. I first used assembly language and then pivoted to C. That&amp;#39;s
where it stayed until I left and I&amp;#39;m guessing it&amp;#39;s still there. If I
were to design the course now, I&amp;#39;m not sure if I&amp;#39;d make the same
choice. If I were designing a unit in a post APCS-A class that had
some low-level work, I&amp;#39;m also not sure what I&amp;#39;d do but I found the
question interesting so I thought I&amp;#39;d noodle about it here.&lt;/p&gt;
&lt;p&gt;
The first question I&amp;#39;d ask would be &amp;#34;should the language be low level
or is it any language suited for low level, that is, systems type
work?&amp;#34; If it&amp;#39;s the former, choices are pretty limited. If it&amp;#39;s the
latter, then most popular mainstream languages would work but
scripting languages like Python and JVM based languages like Java
probably miss the mark, at least philosophically.&lt;/p&gt;
&lt;p&gt;
Let&amp;#39;s explore some of the contenders:&lt;/p&gt;
&lt;div id=&#34;outline-container-headline-1&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-1&#34;&gt;
Assembly
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-1&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
This is what I think of when I hear &amp;#34;low level language.&amp;#34; In some ways
assembly is simple. Each instruction does a specific thing. On the
other hand, since you&amp;#39;re giving the CPU explicit instructions to run,
as opposed to higher level &amp;#34;human&amp;#34; constructs, you need a lot of code
to do &amp;#34;simple&amp;#34; things. Assembly certainly gives a platform to explore
a machine at a low level but if we&amp;#39;re talking only a short unit, it
could be hard to get student buy in. Still, some students might love it.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-2&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-2&#34;&gt;
C
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-2&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
C has long been my go to for low level. I like to think about it as
assembly with better constructs like loops, arrays, structs, and
similar. A nice thing is that it&amp;#39;s syntactically similar to Java which
would have been used in APCS-A. A not so nice thing is that it&amp;#39;s less
forgiving and more error prone. This &amp;#34;feature&amp;#34; does let you explore
concepts like memory management and how the computer arranges things
internally but it can also be incredibly frustrating for students and
programmers alike.&lt;/p&gt;
&lt;p&gt;
One really nice feature of using C is that it&amp;#39;s a small, simple
language. K&amp;amp;R - &lt;strong&gt;the&lt;/strong&gt; book on C is only around 100 pages and the
complete reference manual is a short section in back. It also cleaning
compiles to assembly. A really nice unit is to take some C code and
use &lt;strong&gt;gdb&lt;/strong&gt; - the Gnu Debugger - a free debugging tool that can even be
run online to look at the assembly code generated and step through
it. This gives some of the benefits of studying assembly, a little bit
on how memory and the machine works, a touch of how C is translated
when compiled and is very accessible to students.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-3&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-3&#34;&gt;
C++
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-3&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
C++ is newer and much larger than C. It used to be a C extension but
for a long time it&amp;#39;s been a language in its own right. An advantage of
using C++ is that it&amp;#39;s the core language used in many colleges (with
Java being the other main one) and while it&amp;#39;s a little more cumbersome
to use than C, it&amp;#39;s not much of a step up in complexity until you dive
in to the more advanced concepts. You can also do the &amp;#39;explore
assembly using gdb&amp;#39; stuff I described above.&lt;/p&gt;
&lt;p&gt;
Given current markets, I&amp;#39;d be tempted to go C++ as opposed to C if I
were designing this unit today but for anyone doing so, I&amp;#39;d encourage
you, if you do this, to actually teach C++ sensibilities and not
merely C with C++ constructs. &lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-4&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-4&#34;&gt;
Go
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-4&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
Go&amp;#39;s an interesting one. If I remember correctly, it was designed as a
systems programming language to replace C but at the end of the day it
attracted more Python programmers than C programmers.&lt;/p&gt;
&lt;p&gt;
I&amp;#39;ve only dabbled with it but there&amp;#39;s a lot to like. It&amp;#39;s a small,
simple, clean language. A friend described it as &amp;#34;a minimalist
language with libraries designed by really smart people with good
taste.&amp;#34; I think that&amp;#39;s fair.&lt;/p&gt;
&lt;p&gt;
It&amp;#39;s a compiled language with a blazingly fast compiler and hosts some
nice teaching/learning aids. For instance, it comes with gofmt, a
program that indents go code consistently and design features like
having only one loop construct simplifies things. It also has a
terrific concurrency model but that might not be relevant for a past
APCS-A low level unit.&lt;/p&gt;
&lt;p&gt;
It also appears that you can gdb so I&amp;#39;m guessing it has the same
ability to be used to explore assembly as C and C++.&lt;/p&gt;
&lt;p&gt;
Even though I&amp;#39;m a C guy from way back and taught C++ for the past 7
years at Hunter College, I&amp;#39;d be really tempted to look at Go if I were
exploring low level programming or system programming with a High
School post APCS-A class today.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-5&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-5&#34;&gt;
Rust
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-5&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
Rust is another interesting choice. It seems to be the up and coming
darling systems language of the day. That&amp;#39;s not to say it&amp;#39;s a fad -
there seems to be some solid substance underneath. Like with Go, I&amp;#39;ve
only dabbled and to an even lesser extent.&lt;/p&gt;
&lt;p&gt;
My big concern with it in a high school course, particularly for just
a unit in a high school course is there seems to be a fair amount of
overhead and cognitive load for a beginner.  This overhead gives you
some great protections when programming but it just seems to much
given the high school students lack of experience.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-6&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-6&#34;&gt;
Others (Ada, Swift, Nim)
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-6&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
There are other choices as well. I worked with Ada a bit back in the
day and it would suit the bill. After all it was designed for embedded
systems but it&amp;#39;s less mainstream and is less streamlined than C, C++
or Go. Also, to be honest, I&amp;#39;m so out of date with Ada that I can&amp;#39;t
really say what it looks like today. Swift and Nim also came up as I
poked around for current systems programming languages this morning
but know neither and Swift being apple only would be a concern for me.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;outline-container-headline-7&#34; class=&#34;outline-2&#34;&gt;
&lt;h2 id=&#34;headline-7&#34;&gt;
Conclusions
&lt;/h2&gt;
&lt;div id=&#34;outline-text-headline-7&#34; class=&#34;outline-text-2&#34;&gt;
&lt;p&gt;
So, where would I fall if I had to design this student experience? If
I were pressed for time, I&amp;#39;d probably opt for C++ with C being my
second choice. If I had time to plan, I&amp;#39;d look at Go and Rust but my
gut tells me I&amp;#39;d settle on Go for its minimalism and clean design.&lt;/p&gt;
&lt;p&gt;
In any event, it was an interesting question to ponder on.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Learning a new language - part 2 - Rust</title>
      <link>https://cestlaz.github.io/post/learn-new-language-2/</link>
      <pubDate>Tue, 29 Nov 2022 08:59:11 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/learn-new-language-2/</guid>
      <description>&lt;p&gt;
Last time, I wrote about frustrations in trying to &lt;a href=&#34;https://cestlaz.github.io/post/learn-new-language/&#34;&gt;motivate myself to
learn ocaml&lt;/a&gt;. I could see the strong points but given that I&amp;#39;ve been
using Clojure now for a while, it didn&amp;#39;t really hold any value added
for me in my current situation.&lt;/p&gt;
&lt;p&gt;
Next, I thought I&amp;#39;d explore Rust. On the non-functional style, my go to
languages have always been Python for scripting and small things and C
professionally. I also used and taught C++ and Java. I always loved
C&amp;#39;s minimalism but it was pretty bare bones and Java and C++ while
more modern both also have their warts so it made sense to see if
there was a language I&amp;#39;d like to use instead of any of those three.&lt;/p&gt;
&lt;p&gt;
A number of years ago, I decided to explore Go for this. Go had some
nice features. It didn&amp;#39;t do a full blown object oriented thing but
rather a more lightweight way of defining structures and binding
functionality to structures. I guess like interfaces. Since I&amp;#39;m not a
big OOP person but did like the occasional object abstraction this was
great. I also loved goroutines for concurrency. On the other hand, I
didn&amp;#39;t like the lack of functional goodness so ultimately I stopped
pursuing Go.&lt;/p&gt;
&lt;p&gt;
This time, it was Rust&amp;#39;s turn. Here&amp;#39;s a list of a few of the things
that drew me to Rust:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Good learning resources&lt;/li&gt;
&lt;li&gt;Good dev experience under Emacs&lt;/li&gt;
&lt;li&gt;Static typing&lt;/li&gt;
&lt;li&gt;immutable by default&lt;/li&gt;
&lt;li&gt;Supports the other functional goodness that I like&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I just started playing and so far I like it. In addition to the above
I&amp;#39;m also seeing some other positives. It has pattern matching which I
mentioned in my previous post and the object model looks more like Go
than like C++ or Java so that&amp;#39;s a plus.&lt;/p&gt;
&lt;p&gt;
Another big potential positive is Rust&amp;#39;s concept of ownership. An
informal way of thinking about it is that it&amp;#39;s how Rust deifnes what
can access memory. In Rust,  if you have code like this (lifted from
the Rust Book):&lt;/p&gt;
&lt;div class=&#34;src src-rust&#34;&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; s1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::from(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; s2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; s1;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    println!(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;{}, world!&amp;#34;&lt;/span&gt;, s1);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
you&amp;#39;ll get an error. Once you assign s1 to s2 then s2 owns the memory
with the string &amp;#34;hello&amp;#34; so when you try to access it, you get an
error. Of course, Rust has ways of dealing with this including 
explicitly declared mutability and references and maybe other things I
haven&amp;#39;t gotten to yet so it isn&amp;#39;t really a problem. I can also see it
as being a really strong way of encouraging the writing of safe
programs.&lt;/p&gt;
&lt;p&gt;
I&amp;#39;m pretty early on in the journey - I though I might try Advent of
code this year in Rust but I don&amp;#39;t think I&amp;#39;ll be sufficiently up to
speed on it yet but we&amp;#39;ll see. In any event, it seems to be a very
cool language and a strong C++ or Java alternative.&lt;/p&gt;
&lt;p&gt;
A strong alternative at least in terms of using. For teaching, that&amp;#39;s
another story. For me, learning hasn&amp;#39;t been a problem since I&amp;#39;ve been
around the block a few times but I could see the language being a
challenge for beginners. Lot&amp;#39;s of cognitive overhead for the ownership
thing as well as general scope rules and the way mutability works. I
think all these features are great for the language but I suspect that
it wouldn&amp;#39;t fly very well in a CS0 course.&lt;/p&gt;
&lt;p&gt;
So, I&amp;#39;m feeling that Rust&amp;#39;s a go and I look forward to continuing to
explore the language. If you want to check it out, start here:
&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;&lt;a href=&#34;https://www.rust-lang.org/&#34;&gt;https://www.rust-lang.org/&lt;/a&gt;&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Learning a new language - part 1 - functional</title>
      <link>https://cestlaz.github.io/post/learn-new-language/</link>
      <pubDate>Mon, 21 Nov 2022 17:34:28 -0400</pubDate>
      
      <guid>https://cestlaz.github.io/post/learn-new-language/</guid>
      <description>&lt;p&gt;
Now that I&amp;#39;ve done posting about &lt;a href=&#34;https://cestlaz.github.io/post/retiring-1-why/&#34;&gt;why I&amp;#39;m retiring&lt;/a&gt; we can get back to
our usual blogging.&lt;/p&gt;
&lt;p&gt;
I haven&amp;#39;t really done anything technical over the past couple of
year. The most programming I did in the past 18 months was a
halfhearted effort at the Advent of Code 2021 event last December. I
thought I&amp;#39;d see about picking up a new language to change that. In
doing so, I was reminded of some of my resistances to learning a new
language and how I&amp;#39;ve seen similar from self taught students coming
into my classes.&lt;/p&gt;
&lt;p&gt;
Of course my situation is different - I&amp;#39;m doing this wholly by choice
and once a student is in a class they&amp;#39;ve got to use the prescribed
tool.&lt;/p&gt;
&lt;p&gt;
The contenders on the functional side were Haskell and OCaml and on the
other side, mostly Rust.&lt;/p&gt;
&lt;p&gt;
Today, we&amp;#39;ll talk about the functional side. I decided to look at
OCaml. I had briefly looked at it well over a decade ago but barely
scratched the surface. Haskell I played with a little more deeply but
not much. I decided on OCaml because it was supposed to be more real
world and, to be honest, I get turned off by some of the holier than
though purely functional talk that sometimes occurs.&lt;/p&gt;
&lt;p&gt;
Funny thing is that I&amp;#39;ve had a really hard time getting going - so
much so that I decided that for now I&amp;#39;d explore Rust.&lt;/p&gt;
&lt;p&gt;
So, what&amp;#39;s going on?&lt;/p&gt;
&lt;p&gt;
OCaml looks to have some nice features. It&amp;#39;s functional and I&amp;#39;m a fan
there and it&amp;#39;s also supposed to be pragmatic - you can get real world
stuff done with it. It&amp;#39;s also statically typed which overall I think
is a good thing and it has cool features like pattern matching.&lt;/p&gt;
&lt;p&gt;
For pattern matching, I&amp;#39;m not talking about things like regex or
matching characters in a string but rather something like a really
cool and powerful case or switch statement. Even that description,
though is not doing it justice.&lt;/p&gt;
&lt;p&gt;
I think my problem is that I already am comfortable and enjoy
programming in Clojure. Clojure is functional and pragmatic but while
Clojure doesn&amp;#39;t have pattern matching built in but there is a library
that basically accomplishes the same thing. As to the type system,
Clojure is dynamically typed and while that would be an issue if I
were working on large real projects and/or on a team, I&amp;#39;m just writing
little toys by myself. If I want stronger typing, there are ways of
doing that in Clojure. True, it&amp;#39;s not required but working by myself,
I have that option, should I choose. It&amp;#39;s not the same - I know but as
I said, I&amp;#39;m not doing anything big, important or with other people
right now.&lt;/p&gt;
&lt;p&gt;
So, basically, every time I try to dive in to OCaml, I end up feeling
that &amp;#34;I can already do that and do it better in Clojure.&amp;#34; I&amp;#39;m guessing
I&amp;#39;d feel the reverse had I started on the OCaml side. &lt;/p&gt;
&lt;p&gt;
This has happened to me before. I was an early Python adopter feeling
that it was a huge improvement over Perl. A while later, Ruby came out
and shortly after that, Ruby on Rails became a thing. Every time I
looked into Ruby I had to stop - I could already do and do better in
Python. By then, there were enough tools to compete with Rails even
though they weren&amp;#39;t as mainstream and overall I preferred Python. I
never did end up learning Ruby.&lt;/p&gt;
&lt;p&gt;
I felt a similar sluggishness when I went from C++ to Java - something
I had to do because of the AP Exam change but I pushed through since I
had to teach it and ultimately, I&amp;#39;ve learned to appreciate the good
and curse the bad of both languages.&lt;/p&gt;
&lt;p&gt;
I&amp;#39;ve seen similar blocks or resistance from who&amp;#39;ve had prior
programming experiences over the years. From students who seemed
to be taught more &amp;#34;the language&amp;#34; rather than CS using the language. I
know that&amp;#39;s a nebulous thing to say but I think some of you will catch
my drift. It&amp;#39;s subtleties like saying &amp;#34;okay, we&amp;#39;re repeating this
process, here&amp;#39;s how we do it in language such and such&amp;#34; vs &amp;#34;here&amp;#39;s how
we repeat this process period&amp;#34; and show the language construct.&lt;/p&gt;
&lt;p&gt;
My former math chairman at Stuy said he once, back in the 80s asked Marvin
Minsky what they should be teaching for CS in High School. Minsky
said, and I paraphrase, &amp;#34;nothing, you&amp;#39;ll only mess them up. At most
teach them to type.&amp;#34; Of course that was a different time and I
&lt;strong&gt;strongly&lt;/strong&gt; disagree with that statement but I do think we have to look
at how students entering our classes are or are not prepared and
adjust accordingly. &lt;/p&gt;
&lt;p&gt;
So, in the end, it&amp;#39;s back to Clojure for me on the functional side and
I&amp;#39;ll try to do an OCaml dive sometime in the future.&lt;/p&gt;
&lt;p&gt;
Fortunately, I&amp;#39;m having an easier time getting in to Rust. More about
that next time.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>